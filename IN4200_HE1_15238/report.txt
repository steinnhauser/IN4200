
Count_mutual_links1:

To do this, first loop through all the pages that 4 is linked to. For each
of these, count how many other nodes are also linked to this one. Doing this using the 2D matrix involves moving to column 4, starting from the
top and moving on down, and each time a 1 is encountered ('ToID links'), you
count how many other 1's are in that row ('FromID links' to the node).

j indicates the column. Move from left to right and top to bottom
Check if any of these values equal 1.
If so, we want to count up 1's in that row.


Count_mutual_links2:

// Know that row_ptr tells us how many elements are in each row.
// Know also that col_idx tells us where each of these elements are.
// Need to loop through each node (column), and assert how many more elements
// there are in each of the rows which contain a '1' for that column.



// Finally, generate the col_idx array. Add a verbosity factor for large data.
// int pos = 0, verbosity = 0, fac = (*N)/150 + 1;

// if ((*N)>1e3)
// {
// 	verbosity = 1;
// 	printf("Compressing web data from file %s...\n", filename);
// }

// for (int i = 0; i < (*N); i++) {
// 	// Create a progress bar for visualisation.
// 	if (i % fac == 0 && verbosity)
// 	{
// 		printf("\r[%.3f %%]", 100*(i / (double) *N));
// 		fflush(stdout);
// 	}

//     for (int j = 0; j < (*N_links); j++) {
//         if (ToID[j] == i) {
//             (*col_idx)[pos] = FromID[j];
//             pos++;
//         }
//     }
// }

// if (verbosity) printf("\n");